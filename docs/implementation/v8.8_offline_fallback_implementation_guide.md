# v8.8 Offline Fallback Implementation Guide

> **Status**: âœ… Phase 1 Complete (offline_mode.dart created)
> **Next**: Integrate into repositories and providers
> **Date**: 2025-11-01
> **PRD Reference**: PRD_v8.8_OfflineFallback_Addendum.md

---

## ğŸ“‹ Executive Summary

This guide provides step-by-step instructions for implementing offline fallback functionality in the Pickly mobile app. The offline mode ensures the app remains functional even when Supabase Realtime connection is lost, providing a seamless user experience.

**Current Status**:
- âœ… Core utility created: `/apps/pickly_mobile/lib/core/offline/offline_mode.dart`
- â³ Repository integration: Pending
- â³ Provider updates: Pending
- â³ Testing: Pending

---

## ğŸ¯ Implementation Objectives

### Goals
1. **Instant Fallback**: Switch to cached data within 200ms of connection loss
2. **Auto-Recovery**: Automatically reconnect when network restored (â‰¤0.5s)
3. **Data Persistence**: Cache latest Stream data using SharedPreferences
4. **Seamless UX**: No visible interruption to user experience

### Non-Goals
- âŒ UI changes (PRD v8.5 policy: no UI modifications)
- âŒ Design System changes
- âŒ Benefit categories offline mode (deferred to v9.0)

---

## ğŸ“‚ File Structure

```
apps/pickly_mobile/lib/
â”œâ”€â”€ core/
â”‚   â””â”€â”€ offline/
â”‚       â””â”€â”€ offline_mode.dart âœ… (CREATED)
â”œâ”€â”€ features/benefits/
â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”œâ”€â”€ announcement_repository.dart â³ (UPDATE NEEDED)
â”‚   â”‚   â””â”€â”€ category_banner_repository.dart â³ (UPDATE NEEDED)
â”‚   â””â”€â”€ providers/
â”‚       â”œâ”€â”€ announcement_provider.dart â³ (UPDATE NEEDED)
â”‚       â””â”€â”€ category_banner_provider.dart â³ (UPDATE NEEDED)
â””â”€â”€ contexts/user/
    â””â”€â”€ (age_categories already has offline fallback âœ…)
```

---

## ğŸ—ï¸ Architecture Overview

### Offline Mode Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Supabase Realtime Stream (Normal)             â”‚
â”‚                                                          â”‚
â”‚  Admin Update â†’ Supabase â†’ Flutter Stream â†’ UI Update   â”‚
â”‚                    â†“                                     â”‚
â”‚               Cache Save (SharedPreferences)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Network Failure (Offline Fallback Mode)           â”‚
â”‚                                                          â”‚
â”‚  Stream Error â†’ Load Cache â†’ UI Shows Cached Data       â”‚
â”‚                    â†“                                     â”‚
â”‚           Network Recovery Detection                     â”‚
â”‚                    â†“                                     â”‚
â”‚     Stream Reconnect â†’ UI Updates with Fresh Data       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Flow Pattern

**1. Normal Operation** (Online):
```dart
Stream â†’ map(records) â†’ Parse models â†’ Cache save â†’ Emit to UI
```

**2. Error Handling** (Offline):
```dart
Stream error â†’ Catch â†’ Load from cache â†’ Emit cached data to UI
```

**3. Recovery** (Back Online):
```dart
Stream reconnects â†’ Fresh data arrives â†’ Cache update â†’ Emit to UI
```

---

## ğŸ”§ Implementation Steps

### Step 1: Import Offline Mode Utility âœ…

The core utility has been created at:
```dart
// apps/pickly_mobile/lib/core/offline/offline_mode.dart
```

**Features**:
- Generic cache manager with type safety
- JSON serialization/deserialization
- Cache expiry checking
- Cache statistics
- Helper functions for list operations

**Usage Example**:
```dart
import 'package:pickly_mobile/core/offline/offline_mode.dart';

// Save announcements to cache
await OfflineModeHelpers.saveList<Announcement>(
  OfflineCacheKeys.announcements,
  announcements,
  toJson: (a) => a.toJson(),
);

// Load from cache
final cached = await OfflineModeHelpers.loadList<Announcement>(
  OfflineCacheKeys.announcements,
  fromJson: (json) => Announcement.fromJson(json),
);
```

---

### Step 2: Update Announcement Repository

**File**: `/apps/pickly_mobile/lib/features/benefits/repositories/announcement_repository.dart`

#### Add Import
```dart
import 'package:pickly_mobile/core/offline/offline_mode.dart';
```

#### Update `watchAnnouncements()` Method

**Current**:
```dart
Stream<List<Announcement>> watchAnnouncements({
  String? status,
  bool priorityOnly = false,
}) {
  // Returns stream directly
  return _supabase.from('announcements').stream(...).map(...);
}
```

**New (with offline fallback)**:
```dart
Stream<List<Announcement>> watchAnnouncements({
  String? status,
  bool priorityOnly = false,
}) async* {
  // Try loading cached data first (instant display)
  final cachedData = await OfflineModeHelpers.loadList<Announcement>(
    OfflineCacheKeys.announcements,
    fromJson: (json) => Announcement.fromJson(json),
  );

  if (cachedData != null && cachedData.isNotEmpty) {
    debugPrint('ğŸ’¾ [Offline] Loaded ${cachedData.length} cached announcements');
    yield cachedData; // Emit cached data immediately
  }

  // Start realtime stream
  try {
    await for (final records in _supabase.from('announcements').stream(primaryKey: ['id'])) {
      debugPrint('ğŸ”„ Received ${records.length} announcements from stream');

      var announcements = records
          .map((json) => Announcement.fromJson(json))
          .toList();

      // Apply filters
      if (status != null) {
        announcements = announcements.where((a) => a.status == status).toList();
      }
      if (priorityOnly) {
        announcements = announcements.where((a) => a.isPriority).toList();
      }

      // Sort
      announcements.sort((a, b) {
        final priorityCompare = (b.isPriority ? 1 : 0) - (a.isPriority ? 1 : 0);
        if (priorityCompare != 0) return priorityCompare;
        return b.postedDate.compareTo(a.postedDate);
      });

      // Cache the data for offline use
      await OfflineModeHelpers.saveList<Announcement>(
        OfflineCacheKeys.announcements,
        announcements,
        toJson: (a) => a.toJson(),
      );

      debugPrint('âœ… Stream emitted ${announcements.length} announcements');
      yield announcements;
    }
  } catch (e, stackTrace) {
    debugPrint('âŒ Stream error: $e');
    debugPrint('Stack trace: $stackTrace');

    // On error, try to load cached data if not already emitted
    if (cachedData == null || cachedData.isEmpty) {
      final fallbackData = await OfflineModeHelpers.loadList<Announcement>(
        OfflineCacheKeys.announcements,
        fromJson: (json) => Announcement.fromJson(json),
      );

      if (fallbackData != null && fallbackData.isNotEmpty) {
        debugPrint('ğŸ’¾ [Offline Fallback] Using cached announcements');
        yield fallbackData;
      } else {
        debugPrint('âš ï¸ [Offline] No cached data available');
        rethrow; // No cache available, propagate error
      }
    }
  }
}
```

#### Update Other Stream Methods

Apply the same pattern to:
- `watchAnnouncementsByType()`
- `watchAnnouncementById()`

**Cache Keys**:
- `watchAnnouncementsByType()`: Use `OfflineCacheKeys.announcementById(typeId)`
- `watchAnnouncementById()`: Use `OfflineCacheKeys.announcementById(id)`

---

### Step 3: Update Category Banner Repository

**File**: `/apps/pickly_mobile/lib/features/benefits/repositories/category_banner_repository.dart`

#### Add Import
```dart
import 'package:pickly_mobile/core/offline/offline_mode.dart';
```

#### Update `watchActiveBanners()` Method

**Pattern** (same as announcements):
```dart
Stream<List<CategoryBanner>> watchActiveBanners() async* {
  // Load cached data first
  final cachedData = await OfflineModeHelpers.loadList<CategoryBanner>(
    OfflineCacheKeys.categoryBannersActive,
    fromJson: (json) => CategoryBanner.fromJson(json),
  );

  if (cachedData != null && cachedData.isNotEmpty) {
    debugPrint('ğŸ’¾ [Offline] Loaded ${cachedData.length} cached banners');
    yield cachedData;
  }

  // Start realtime stream
  try {
    await for (final records in _supabase.from('category_banners').stream(primaryKey: ['id'])) {
      final banners = records
          .where((json) => json['is_active'] as bool? ?? false)
          .map((json) => CategoryBanner.fromJson(json))
          .toList()
        ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));

      // Cache for offline use
      await OfflineModeHelpers.saveList<CategoryBanner>(
        OfflineCacheKeys.categoryBannersActive,
        banners,
        toJson: (b) => b.toJson(),
      );

      yield banners;
    }
  } catch (e) {
    debugPrint('âŒ Stream error: $e');

    if (cachedData == null || cachedData.isEmpty) {
      final fallbackData = await OfflineModeHelpers.loadList<CategoryBanner>(
        OfflineCacheKeys.categoryBannersActive,
        fromJson: (json) => CategoryBanner.fromJson(json),
      );

      if (fallbackData != null && fallbackData.isNotEmpty) {
        debugPrint('ğŸ’¾ [Offline Fallback] Using cached banners');
        yield fallbackData;
      } else {
        rethrow;
      }
    }
  }
}
```

#### Update Other Stream Methods

Apply to:
- `watchBannersForCategory()`
- `watchBannersBySlug()`
- `watchBannerById()`

---

### Step 4: Update Providers (Optional but Recommended)

**File**: `/apps/pickly_mobile/lib/features/benefits/providers/announcement_provider.dart`

No changes needed! Providers automatically work with the updated Stream from repositories.

**However**, you can add offline status indicators:

```dart
/// Provider to check if using cached data
final announcementsUsingCacheProvider = Provider<bool>((ref) {
  // This would require additional state management
  // For v8.8, we keep it simple and rely on console logs
  return false;
});
```

---

## ğŸ§ª Testing Plan

### Test 1: Offline Cache Loading

**Scenario**: App starts with no network connection

**Steps**:
1. Disconnect WiFi/mobile data
2. Launch Flutter app
3. Navigate to announcements screen

**Expected**:
- âœ… Cached announcements load within 100ms
- âœ… UI shows last synced data
- âœ… Console log: `ğŸ’¾ [Offline] Loaded X cached announcements`
- âœ… No error messages shown to user

### Test 2: Network Disconnection During Use

**Scenario**: Network drops while using app

**Steps**:
1. Start app with network connected
2. Load announcements (fresh from Supabase)
3. Disconnect network
4. Pull-to-refresh (if applicable)

**Expected**:
- âœ… Cached data continues to display
- âœ… Console log: `ğŸ’¾ [Offline Fallback] Using cached announcements`
- âœ… No app crash or blank screen
- âœ… Cached data is same as last synced data

### Test 3: Auto-Recovery

**Scenario**: Network reconnects after disconnection

**Steps**:
1. Start with network disconnected (using cache)
2. Make Admin changes while offline
3. Reconnect network

**Expected**:
- âœ… Stream automatically reconnects within 0.5s
- âœ… Fresh data arrives from Supabase
- âœ… UI updates with latest announcements
- âœ… Cache is updated with fresh data
- âœ… Console log: `âœ… Stream emitted X announcements` (fresh data)

### Test 4: Cache Expiry

**Scenario**: Cached data is >24 hours old

**Steps**:
1. Load app with old cached data (>24h)
2. Check if app shows stale data warning

**Expected**:
- â³ For v8.8: No expiry enforcement (future enhancement)
- âœ… Data still loads from cache
- âœ… Stream updates replace stale cache when online

### Test 5: No Cache Available

**Scenario**: First app launch, no cache exists

**Steps**:
1. Fresh app install
2. Start app without network

**Expected**:
- âœ… No cached data found
- âœ… Error state shown (empty list or retry prompt)
- âœ… Console log: `âš ï¸ [Offline] No cached data available`
- âœ… App doesn't crash

### Test 6: Cache Performance

**Scenario**: Measure cache load speed

**Steps**:
1. Cache 100+ announcements
2. Disconnect network
3. Launch app and measure load time

**Expected**:
- âœ… Cache load time <100ms
- âœ… UI shows data instantly
- âœ… No lag or freezing

---

## ğŸ“Š Performance Targets

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| **Cache load time** | â‰¤100ms | Flutter DevTools Timeline |
| **Network detection** | â‰¤200ms | Console log timestamps |
| **Auto-recovery time** | â‰¤0.5s | Stream reconnect measurement |
| **Cache save time** | â‰¤50ms | Async operation, non-blocking |
| **Memory overhead** | <1MB | Flutter DevTools Memory |

---

## ğŸš¨ Known Limitations & Future Work

### Current Limitations (v8.8)

1. **No Cache Expiry Enforcement**
   - Cached data never expires automatically
   - Future: Add `isExpired()` check on load
   - Future: Show "Viewing offline data" indicator

2. **No Connectivity Detection**
   - Uses Supabase error handling instead
   - Future: Use `connectivity_plus` package
   - Future: Show connection status icon

3. **No Cache Size Management**
   - Cache grows unbounded
   - Future: Implement LRU eviction
   - Future: Set max cache size (e.g., 5MB)

4. **No Partial Updates**
   - Cache saves entire list on every update
   - Future: Implement delta updates
   - Future: Use IndexedDB for larger datasets

### Future Enhancements (v9.0+)

1. **Smart Cache Invalidation**
   ```dart
   // Check if cache is stale before using
   if (await offlineMode.isExpired(key, maxAge: Duration(hours: 24))) {
     // Show "Data may be outdated" indicator
   }
   ```

2. **Connectivity Monitoring**
   ```dart
   // Use connectivity_plus package
   final connectivity = Connectivity();
   connectivity.onConnectivityChanged.listen((result) {
     if (result != ConnectivityResult.none) {
       // Trigger stream refresh
     }
   });
   ```

3. **Cache Statistics UI**
   ```dart
   // Show cache info in settings
   final stats = await offlineMode.getStats();
   // Display: "Using 2.3 MB offline cache, last synced 5 min ago"
   ```

4. **Benefit Categories Offline Mode**
   - Implement after Phase 3 (benefit_categories Stream migration)
   - Remove hardcoded UI categories
   - Add offline cache for dynamic categories

---

## ğŸ“‹ Implementation Checklist

### Phase 1: Core Utility âœ…
- [x] Create `offline_mode.dart` with OfflineMode class
- [x] Implement save/load methods with JSON serialization
- [x] Add cache expiry checking
- [x] Create OfflineCacheKeys constants
- [x] Add helper functions for list operations
- [x] Document usage patterns

### Phase 2: Repository Integration â³
- [ ] Update `announcement_repository.dart`
  - [ ] Add offline fallback to `watchAnnouncements()`
  - [ ] Add offline fallback to `watchAnnouncementsByType()`
  - [ ] Add offline fallback to `watchAnnouncementById()`
- [ ] Update `category_banner_repository.dart`
  - [ ] Add offline fallback to `watchActiveBanners()`
  - [ ] Add offline fallback to `watchBannersForCategory()`
  - [ ] Add offline fallback to `watchBannersBySlug()`
  - [ ] Add offline fallback to `watchBannerById()`

### Phase 3: Provider Updates â³
- [ ] Test `announcement_provider.dart` with offline mode
- [ ] Test `category_banner_provider.dart` with offline mode
- [ ] Verify StreamProvider auto-updates work correctly

### Phase 4: Testing â³
- [ ] Test 1: Offline cache loading
- [ ] Test 2: Network disconnection during use
- [ ] Test 3: Auto-recovery
- [ ] Test 4: Cache expiry (verify no enforcement)
- [ ] Test 5: No cache available (first launch)
- [ ] Test 6: Cache performance (<100ms load)

### Phase 5: Documentation â³
- [ ] Update README with offline mode info
- [ ] Create user guide for offline features
- [ ] Document cache management for developers
- [ ] Update test reports with offline scenarios

---

## ğŸ¯ Success Criteria

**Technical Success**:
- âœ… Cache loads in <100ms
- âœ… Network errors don't crash app
- âœ… Auto-recovery works within 0.5s
- âœ… Memory usage <1MB for cache
- âœ… Zero data loss during reconnection

**User Experience Success**:
- âœ… No visible interruption when going offline
- âœ… Data appears instantly on app launch (offline)
- âœ… Smooth transition from cached to live data
- âœ… No error dialogs or blank screens

**Quality Success**:
- âœ… All tests passing
- âœ… No regressions in existing functionality
- âœ… Code review approved
- âœ… Documentation complete

---

## ğŸ“ Related Documents

**PRD**:
- PRD_v8.8_OfflineFallback_Addendum.md

**Code**:
- `/apps/pickly_mobile/lib/core/offline/offline_mode.dart` âœ…
- `/apps/pickly_mobile/lib/features/benefits/repositories/announcement_repository.dart` â³
- `/apps/pickly_mobile/lib/features/benefits/repositories/category_banner_repository.dart` â³

**Testing**:
- `/docs/testing/realtime_stream_report_v8.6_phase5.md` (baseline performance)
- `/docs/testing/offline_fallback_report_v8.8.md` (to be created)

---

**Implementation Status**: âœ… **Phase 1 Complete** (Core utility ready)
**Next Steps**: Integrate into repositories and test offline scenarios
**Estimated Time**: 4-6 hours (integration + testing)
**Risk Level**: ğŸŸ¢ **Low** (non-breaking, additive changes only)
